{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Task Badger Documentation","text":"<p>Task Badger is a specialized monitoring system designed to provide deep visibility into your background jobs and asynchronous tasks. While it doesn't handle task execution itself, Task Badger seamlessly integrates with popular task processing systems like Celery to give developers comprehensive insights into their task operations. With Task Badger, you can track task progress, analyze performance patterns, and debug issues across your distributed task processing infrastructure. Whether you're managing a small set of periodic jobs or orchestrating complex distributed workflows, Task Badger offers the monitoring and observability tools you need to ensure your tasks are running smoothly.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Task States: Track the status of tasks with various states such as <code>pending</code>, <code>in_progress</code>, <code>completed</code>, <code>error</code>, and more.</li> <li>Actions and Triggers: Automate actions based on task events using flexible trigger definitions.</li> <li>Integrations: Connect with various services like email, webhooks, and more to extend the functionality of Task Badger</li> <li>Monitoring and Alerts: Stay informed with real-time monitoring and customizable alerts for task events.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Task Badger, check out the following sections:</p> <ul> <li>Quick Start Guide: Learn how to set up and start using Task Badger.</li> <li>Task States: Understand the different states a task can be in and how they are managed.</li> <li>Task Actions: Discover how to configure actions and triggers to automate your workflows.</li> <li>API Reference: Explore the API documentation to integrate Task Badger with your applications.</li> <li>Python SDK: Get started with the Python SDK to interact with Task Badger programmatically.</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<p>Join our community to get help, share ideas, and stay updated with the latest news:</p> <ul> <li>GitHub: Report issues, contribute to the project, and browse the source code.</li> <li>Twitter: Follow us for updates and announcements.</li> </ul> <p>We hope you find Task Badger useful and look forward to your feedback!# Welcome to Task Badger Documentation</p>"},{"location":"api/","title":"API Endpoints","text":"<p>All tasks (and related data) is associated with a single project. The base task URL is:</p> <pre><code>/api/{organization}/{project}/tasks\n</code></pre> Action Endpoint List tasks <code>GET /api/{org}/{project}/tasks</code> Create task <code>POST /api/{org}/{project}/tasks</code> Get task details <code>GET /api/{org}/{project}/tasks/{task_id}</code> Update task <code>PATCH /api/{org}/{project}/tasks/{task_id}</code> Cancel task <code>DELETE /api/{org}/{project}/tasks/{task_id}</code> List task actions <code>GET /api/{org}/{project}/tasks/{task_id}/actions/</code> Add task action <code>POST /api/{org}/{project}/tasks/{task_id}/actions/</code>(alternately POST to 'update task' endpoint with {\"actions\": [...]}) Update task action <code>PATCH /api/{org}/{project}/tasks/{task_id}/actions/{action_id}/</code> Cancel task action <code>DELETE /api/{org}/{project}/tasks/{task_id}/actions/{action_id}/</code> <p>Full details of the API endpoints can be viewed at https://taskbadger.net/api/docs/</p>"},{"location":"api/#errors","title":"Errors","text":""},{"location":"api/#401-unauthorized","title":"401 Unauthorized","text":"<p>These errors are returned with the status code 401 whenever the authentication fails or a request is made to an endpoint without providing the authentication information as part of the request. Here are the 2 possible errors that can be returned. <pre><code>{\n    \"type\": \"client_error\",\n    \"errors\": [\n        {\n            \"code\": \"authentication_failed\",\n            \"detail\": \"Incorrect authentication credentials.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"type\": \"client_error\",\n    \"errors\": [\n        {\n            \"code\": \"not_authenticated\",\n            \"detail\": \"Authentication credentials were not provided.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre></p>"},{"location":"api/#405-method-not-allowed","title":"405 Method Not Allowed","text":"<p>This is returned when an endpoint is called with an unexpected http method. For example, if updating a user requires a POST request and a PATCH is issued instead, this error is returned. Here's how it looks like:</p> <pre><code>{\n    \"type\": \"client_error\",\n    \"errors\": [\n        {\n            \"code\": \"method_not_allowed\",\n            \"detail\": \"Method \u201cpatch\u201d not allowed.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"api/#406-not-acceptable","title":"406 Not Acceptable","text":"<p>This is returned if the <code>Accept</code> header is submitted and contains a value other than <code>application/json</code>. Here's how the response would look:</p> <pre><code>{\n    \"type\": \"client_error\",\n    \"errors\": [\n        {\n            \"code\": \"not_acceptable\",\n            \"detail\": \"Could not satisfy the request Accept header.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"api/#415-unsupported-media-type","title":"415 Unsupported Media Type","text":"<p>This is returned when the request content type is not json. Here's how the response would look:</p> <pre><code>{\n    \"type\": \"client_error\",\n    \"errors\": [\n        {\n            \"code\": \"not_acceptable\",\n            \"detail\": \"Unsupported media type \u201capplication/xml\u201d in request.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"api/#500-internal-server-error","title":"500 Internal Server Error","text":"<p>This is returned when the API server encounters an unexpected error. Here's how the response would look:</p> <pre><code>{\n    \"type\": \"server_error\",\n    \"errors\": [\n        {\n            \"code\": \"error\",\n            \"detail\": \"A server error occurred.\",\n            \"attr\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"basics/","title":"Using the Task Badger API","text":""},{"location":"basics/#organization-and-project","title":"Organization and Project","text":"<p>API endpoints include both the <code>organization</code> and <code>project</code> slug. The user authenticating the request must have access to both for the request to be accepted.</p> <ul> <li>Organization slug<ul> <li>You can get this by going to 'My Organization'  </li> </ul> </li> <li>Project slug<ul> <li>Go to the 'Projects' page. The slug for each project is listed. </li> </ul> </li> </ul>"},{"location":"basics/#authentication","title":"Authentication","text":"<p>Requests must be authenticated by providing a bearer token provided in the Authentication header. You can generate a token by going to your user profile page.</p> <pre><code>POST https://taskbadger.net/api/{organization}/{project}/tasks/\nAuthorization: Bearer xxxx\nContent-type: application/json\n{\"name\":\"demo task\",\"status\":\"pending\"}\n</code></pre>"},{"location":"basics/#request-bodies","title":"Request bodies","text":"<p>The payload of HTTP POST requests must be specified as JSON.  The Content-type HTTP header must be set to <code>application/json</code> Without this header the data won't be interpreted as JSON.</p> <p>For example:</p> <pre><code>POST https://taskbadger.net/api/{organization}/{project}/tasks/\nAuthorization: Bearer xxxx\nContent-type: application/json\n{\"name\":\"demo task\",\"status\":\"pending\"}\n</code></pre>"},{"location":"basics/#request-methods","title":"Request methods","text":"<p>Task Badger uses standard REST methods: </p> Method Function GET Retrieve an object or list of objects POST Create an object PUT Update an object (complete data required) PATCH Update an object (partial data required) DELETE Delete or mark object as deleted or cancelled"},{"location":"basics/#pagination","title":"Pagination","text":"<p>List requests use cursor pagination. Each request will include a <code>next</code> and <code>previous</code> field. These may be null indicating that is no next or previous page but will otherwise contain the full URL of the page.</p> <p>The cursors can be used to navigate forwards or backwards through the data. For example:</p> <pre><code>GET https://taskbadger.net/api/{organization}/{project}/tasks/?page_size=2\n</code></pre> <p>This will respond with tasks in pages of size 2:</p> <pre><code>{\n  \"previous\": null,\n  \"next\": \"https://taskbadger.net/api/{organization}/{project}/tasks/?cursor=XXX&amp;page_size=2\",\n  \"results\": [{...}, {...}]\n}\n</code></pre> <p>To access the next page of data make a request to the URL provided in the <code>next</code> field:</p> <pre><code>GET https://taskbadger.net/api/{organization}/{project}/tasks/?cursor=XXX&amp;page_size=2\n</code></pre> <p>The response will now include both <code>next</code> and <code>previous</code> page URLs.</p> <pre><code>{\n  \"previous\": \"https://taskbadger.net/api/{organization}/{project}/tasks/?cursor=YYY&amp;page_size=2\",\n  \"next\": \"https://taskbadger.net/api/{organization}/{project}/tasks/?cursor=ZZZ&amp;page_size=2\",\n  \"results\": [{...}, {...}]\n}\n</code></pre> <p>Tip</p> <p>The <code>page_size</code> parameter can be changed at any point to adjust the page size of the request.</p>"},{"location":"basics/#rate-limiting","title":"Rate Limiting","text":"<p>Rate limits are applied to API requests based on the Organization subscription plan. Requests that have been rate limited will respond as follows:</p> <pre><code>HTTP/1.1 429 Too Many Requests\nRetry-After: 30\n</code></pre>"},{"location":"basics/#openapi-specification","title":"OpenAPI Specification","text":"<p>The Task Badger API includes an endpoint for downloading the OpenAPI 2.0 specification which describes the requests and responses.</p> <p>Download the spec from taskbadger.net</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v161","title":"v1.6.1","text":"<p>2025-03-04</p> <p>Python SDK</p> <ul> <li>UPDATE Deprecate <code>task.update_progress</code> and <code>task.increment_progress</code> in favour of <code>task.update_value</code> and <code>task.increment_value</code>.</li> <li>UPDATE Return boolean from <code>task.udpate_value</code> and <code>task.ping</code> to indicate whether an update was made.</li> </ul>"},{"location":"changelog/#v160","title":"v1.6.0","text":"<p>2025-03-03</p> <p>Python SDK</p> <ul> <li>NEW Add optional rate limiting for task updates when calling <code>task.ping</code> and <code>task.update_progress</code></li> </ul>"},{"location":"changelog/#v150","title":"v1.5.0","text":"<p>2025-02-14</p> <ul> <li>NEW Tasks now support tagging. Tags are useful for categorizing tasks and filtering them in the UI. See Task Tags for more information.</li> </ul> <p>Python SDK</p> <ul> <li>NEW Support for tagging.</li> <li>NEW <code>before_create</code> callback to allow modification of task data before it is created. This is useful for adding global tags and metadata to tasks such as the current tenant etc. See Before Create Callback for more information.</li> </ul>"},{"location":"changelog/#v140","title":"v1.4.0","text":"<p>2025-02-10</p> <p>Python SDK</p> <ul> <li>NEW Add option to <code>CelerySystemIntegration</code> to automatically record Celery task arguments in task data.</li> </ul>"},{"location":"cli/","title":"Using the Task Badger CLI","text":"<p>The CLI (command line interface) is a tool that allows you to interface with Task Badger via the shell. This makes it easy to integrate it into workflows without the need to write any code.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is bundled with the Python client library. To install it you need:</p> <ul> <li>Python &gt; 3.7</li> </ul> <p>The recommended approach is to install the CLI into a virtual environment using pipx:</p> <pre><code>$ pipx install taskbadger\n</code></pre> <p>Alternatively you can install it into your user environment using pip:</p> <pre><code>$ python3 -m pip install --user taskbadger\n</code></pre>"},{"location":"cli/#monitoring-processes","title":"Monitoring processes","text":"<p>The main feature of the CLI is the <code>run</code> command which allows you to track tasks that are started from the command line:</p> <pre><code>$ taskbadger run \"demo task\" -- path/to/script.sh\n\nTask created: https://taskbadger.net/public/tasks/xyz/\n</code></pre> <p>The task status will be updated once the command completes. The task status will be <code>success</code> if the command has a zero exit code. Any other exit code will result in an <code>error</code> status and the exit code will be saved in the task data under the <code>return_code</code> key.</p>"},{"location":"cli/#basic-commands","title":"Basic commands","text":"<p>The CLI has a number of basic commands that allow you to interact with the Task Badger API. The commands are:</p> <ul> <li><code>list</code> - List tasks</li> <li><code>get</code> - Get a task</li> <li><code>create</code> - Create a task</li> <li><code>update</code> - Update a task</li> </ul> <p>For more details on these commands run <code>taskbadger &lt;command&gt; --help</code>.</p>"},{"location":"cli/#actions","title":"Actions","text":"<p>You can create actions for CLI tasks using the <code>--action</code> (<code>-a</code>) argument. The format for this argument is string with three components, separated by a space:</p> <pre><code>flowchart LR\n    trigger --- integration\n    integration --- config</code></pre> <p>The config parameter is a comma-separated list of key value pairs.</p> <p>Here is an example:</p> <pre><code>$ taskbadger run \"demo task\" --action error email to:me@test.com -- path/to/script.sh\n</code></pre> <p>If the task state becomes <code>stale</code> or <code>error</code>, use the <code>email</code> integration to send a notification to <code>me@test.com</code>.</p>"},{"location":"cli/#configuration","title":"Configuration","text":"<p>The CLI requires the same configuration as the API. This can be provided in one of three ways (in order of precedence):</p> <ol> <li>Command line arguments</li> <li>Environment variables</li> <li>Config file</li> </ol> <p>Values provided via environment variables override values in the configuration file and values provided via the command line override both environment config and the configuration file.</p> <p>Details about the configuration parameters can be found here</p>"},{"location":"cli/#command-line-arguments","title":"Command line arguments","text":"<p>Running <code>taskbadger -h</code> will show you the command line help. </p> <pre><code> $ taskbadger -h\n\n Usage: taskbadger [OPTIONS] COMMAND [ARGS]...                                                              \n\n Task Badger CLI                                                                                            \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --org                 -o   TASKBADGER_ORG      \u2502\n\u2502                                                \u2502\n\u2502 --project             -p   TASKBADGER_PROJECT  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The API Key can not be provided via the command line as a security measure to prevent logging of the API Key.</p>"},{"location":"cli/#environment-variables","title":"Environment variables","text":"<p>Use the following environment variable names to configure the CLI:</p> <ul> <li><code>TASKBADGER_API_KEY</code></li> <li><code>TASKBADGER_ORG</code></li> <li><code>TASKBADGER_PROJECT</code></li> </ul>"},{"location":"cli/#configuration-file","title":"Configuration file","text":"<p>The CLI includes a convenience command to create the configuration file. Running the <code>configure</code> command will prompt you for the configuration parameters and save them to the configuration file.</p> <pre><code>$ taskbadger configure\n\nOrganization slug: my-org \nProject slug: project-x \nAPI Key: XYZ.ABC \n\nConfig written to ~/.config/taskbadger/config\n</code></pre>"},{"location":"cli/#tags","title":"Tags","text":"<p>Tags can also be added to the configuration file:</p> <pre><code>[tags]\nenvironment = \"production\"\nhost = \"server-1\"\n</code></pre>"},{"location":"data_model/","title":"Task Badger's Data Model","text":"<p>Tip</p> <pre><code>You can view and download the OpenAPI schema from\n[https://taskbadger.net/api/docs/](https://taskbadger.net/api/docs/){:target=\"_blank\"}\n</code></pre>"},{"location":"data_model/#task","title":"Task","text":"<p>Naturally, the Task is the core data model for Task Badger. Almost all operations are related to a task. </p> <p>Every Task must belong to a Project. You can think of a project as a single 'system' or piece of software. Assigning tasks to a Project is useful when it comes to data segregation and metrics.</p> <p>The main attributes or a task are:</p> <code>name</code> <p>Each task should have a name which identifies the type of task, not necessarily the specific instance of the task. For example, <code>account.export_transactions</code> may be the name of a task that is executed to compile a data export for download.</p> <code>status</code> <p>The status of the task indicates where it is in the task lifecycle</p> <code>value</code> <p>The value of a task indicates its progress in the <code>processing</code> state. By default, the value range is from 0 to 100 (see value_max). </p> <code>value_max</code> <p>This represents the value a task is expected to reach when it is complete. The default for value_max is 100, but it can be changed to any value e.g. the total number o items to be processed.</p> <code>value_percent</code> <p>This is a computed percentage which is equivalent to <code>100 * value / value_max</code>. This will be <code>null</code> if value is null.</p> <code>data</code> <p>This can be used to store arbitrary JSON data that may be useful to store along with the task such as task arguments.</p> <code>max_runtime</code> <p>This value can be used in conjunction with task actions and monitors to trigger actions if a task exceeds its expected runtime. The value is in seconds.</p> <code>stale_timeout</code> <p>This represents the maximum number of seconds allowed between task updates. If a task does not receive  updates within this period it will be marked as 'stale'.</p> <code>tags</code> <p>A list of tags that can be used to categorize tasks. Tags are useful for filtering tasks in the UI. Each tag has a name and a value. For example, a task may have a tag <code>environment:production</code>.</p>"},{"location":"data_model/#example-task","title":"Example Task","text":"<pre><code>{\n  \"id\": \"57ae8eVBrH7jbDgmYj6Ut2vR9S\",\n  \"organization\": \"example_org\",\n  \"project\": \"example_project\",\n  \"name\": \"example task\",\n  \"status\": \"processing\",\n  \"value\": 42,\n  \"value_max\": 200,\n  \"value_percent\": 21,\n  \"data\": {\n    \"property1\": \"customValue\"\n  },\n  \"max_runtime\": null,\n  \"stale_timeout\": null,\n  \"start_time\": \"2022-08-24T15:15:22Z\",\n  \"end_time\": null,\n  \"created\": \"2022-08-24T14:15:22Z\",\n  \"updated\": \"2022-08-24T16:15:22Z\",\n  \"url\": \"https://taskbadger.net/a/{example_org/tasks/57ae8eVBrH7jbDgmYj6Ut2vR9S/\",\n  \"public_url\": \"https://taskbadger.net/public/tasks/57ae8eVBrH7jbDgmYj6Ut2vR9S/\",\n  \"tags\": [\n    {\"environment\": \"production\"}\n  ]\n}\n</code></pre>"},{"location":"data_model/#task-lifecycle","title":"Task Lifecycle","text":"<p>The potential lifecycle of a task has 4 incremental states and 3 terminal states. A task would usually only ever take on one terminal state and may use any or all of the incremental states. </p> <p><pre><code>flowchart LR\n    p(Pending) --&gt; prep(Pre-Processing)\n    prep --&gt; pro(fa:fa-ban Processing)\n    pro --&gt; post(fab:fa-twitter Post-Processing)\n    post --&gt; s(Success)\n    style p stroke-dasharray: 5 5\n    style pro stroke-width:2px\n    style s stroke-width:2px\n\n    st(Stale)\n    c(Cancelled)\n    e(Error)</code></pre> Here are some examples:</p> <p>Manual data migration</p> <ol> <li>The data migration script is executed from the command line by an operator. Immediately on starting    it creates a task in the <code>processing</code> state with a value of <code>0</code>.</li> <li>The script iterates through rows from a database query and performs some action with each. At regular    intervals the script updates the task with its progress by updating the <code>value</code> attribute.</li> <li>Upon completion the script updates the task status to <code>success</code>.</li> </ol> <p>User initiated data export</p> <ol> <li>A user makes a request for data via a web UI. A request is made to Task Badger to create a task record    in the <code>pending</code> state. The task ID and other parameters are placed in a queue. The user is then directed    to a UI which shows the task status and progress.</li> <li>On the backend a task worker receives the task from the queue and executes the export function.</li> <li>The export function updates the Task Badger task state to <code>processing</code> and the <code>value</code> to 0 before    starting the export.</li> <li>During the data export the export function regularly updates the task progress which is also displayed    on the UI for the user.</li> <li>Once the export is compiled the export function updates the task value to 100 and the state to    <code>post_processing</code>. During this time the export function uploads the compiled export to S3.</li> <li>Once the upload is complete the task status is updated to <code>success</code> and the user is presented with    an option to download the export.</li> </ol> <p>At any point during this process the user may press Cancel on the UI which will update the task status. The backed export function could check the task state periodically and exit early.</p>"},{"location":"data_model/#task-state-detail","title":"Task state detail","text":""},{"location":"data_model/#initial-states","title":"Initial states","text":"<code>pending</code> <p>Prior to starting execution a task may be in pending state. This typically happens while a task is waiting in a queue before being selected for execution by a task worker.</p>"},{"location":"data_model/#execution-states","title":"Execution states","text":"<code>pre_processing</code> <p>In this state a task has not yet begun iterating through its dataset, but it may be doing preliminary work. For example, loading data from a file prior to iterating.</p> <code>processing</code> <p>This is the main state of a task during which it is iterating through the data and incrementing its progress as it goes by updating its <code>value</code>.</p> <code>post_processing</code> <p>Having completed processing a task may perform additional work to clean up or finalize the task.</p>"},{"location":"data_model/#terminal-states","title":"Terminal states","text":"<p>These states are mutually exclusive, once a task reaches one of these states it is not expected to be modified again (with the potential exception of 'stale').</p> <code>success</code> <p>The task has completed successfully. Typically, a task would move to this state from the <code>processing</code> or <code>post_processing</code> state.</p> <code>error</code> <p>The task has errored. A task may take on this state at any point.</p> <code>cancelled</code> <p>The task has been cancelled. A task may take on this state at any point.</p>"},{"location":"data_model/#other-states","title":"Other states","text":"<code>stale</code> <p>The task has become stale. This will happen if the task has not reached one of the terminal states AND the duration since it's last update exceeds the tasks <code>stale_timeout</code> value (seconds). The transition to this state is managed by Task Badger automatically. A task in this state may transition to any other state via an update.</p>"},{"location":"data_model/#task-actions","title":"Task Actions","text":"<p>Actions are at the core of Task Badger's secret sauce. They allow you to send notifications, perform callouts, and more based on task events.</p> <p>Every action specifies an integration e.g. <code>email</code>, and a trigger definition which is like a crontab expression, but for tasks. For example, <code>*/25%,success</code> means, \"execute this action when the task value passes 25%, 50%, 75%, 100% and when the task status is set to <code>success</code>\".</p> <p>A task may have multiple actions, each with their own integration and trigger definition.</p> <p>Here is an example of an action:</p> <pre><code>{\n  \"id\": 640,\n  \"task\": \"57ae8eVBrH7jbDgmYj6Ut2vR9S\",\n  \"trigger\": \"success,error\",\n  \"integration\": \"email\",\n  \"status\": \"active\",\n  \"config\": {\n    \"to\": \"me@example.com,you@example.com\"\n  },\n  \"created\": \"2022-11-16T07:10:30.551808Z\",\n  \"updated\": \"2022-11-16T07:10:30.551818Z\"\n}\n</code></pre>"},{"location":"data_model/#action-triggers","title":"Action Triggers","text":"<p>An action trigger is a comma-separated list of trigger points. Each trigger point is one of the following:</p> <ul> <li>A numeric value which is matched against the task <code>value</code>.</li> <li>A percentage value which is matched against the task <code>value_percent</code>.</li> <li>A task status which is matched against the task <code>status</code>.</li> <li>A special value <code>max_runtime_exeeded</code> which is matched when the task exceeds its <code>max_runtime</code> value.</li> </ul> <p>Numeric and percentage trigger points can also be prefixed with <code>*/</code> to indicate that the trigger should fire at regular intervals. For example, <code>*/50%</code> will fire at 0%, 50% and 100%.</p> <p>Examples:</p> Trigger Trigger Fire Points <code>*/30%</code> When <code>value_percent</code> passes any multiple of 30%: 0%, 30%, 60%, 90% <code>success,error,stale</code> When the state changes to any of the listed states <code>95%,250,error</code> At 95%, when the value reaches or passes 250, when the state becomes <code>error</code>"},{"location":"data_model/#action-edge-cases","title":"Action Edge cases","text":"<p>If a task value or status skips past multiple trigger points, only the last matching trigger will be executed.</p> <p>For example, an action configured with <code>20,40,80</code> whose value goes from <code>0</code> directly to <code>90</code> will skip over the <code>20</code> and <code>40</code> events and only fire the <code>80</code> event. This also applies to task status triggers.</p> <p>This also applies to multiple trigger points that are reached simultaneously, for example, let's say an action has the following trigger: <code>100,success</code>. It is quite likely that the task could reach both those states at the same time but the action will only fire once.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Task Badger integrations are what power the actions. When an action is triggered it causes the specified integration to execute.</p> <p>Each action specifies the integration ID as well as a set of configuration used by the integration.</p>"},{"location":"integrations/#email","title":"Email","text":"<p>Email a set of recipients with the current status of the task.</p> <p>Integration ID: <code>email</code></p> <p>Configuration</p> Parameter Description <code>to</code> Comma-separated list of recipient email addresses. Max 5. <p>Example Usage</p> PythonCliShell <pre><code>action = Action(\n    \"success,error\",\n    integration=EmailIntegration(to=\"me@example.com\")\n)\ntask = Task.create(name=\"task name\", actions=[action])\n</code></pre> <pre><code>taskbadger run \"demo task\" --action error,sucess email to:me@test.com -- path/to/script.sh\n</code></pre> <pre><code>$ curl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"demo\", \"actions\":[{\"integration\":\"email\",\"trigger\":\"success,error\",\"config\":{\"to\":\"me@example.com\"}}]}'\n</code></pre>"},{"location":"integrations/#web-hook","title":"Web Hook","text":"<p>The web hook integration allows you to call a URL with a task payload.</p> <p>For security reasons web hooks must first be created on the web UI before they can be used in task actions. This can be done by going to Integrations in the sidebar navigation.</p> <p>Each web hook will have its own unique ID which is what will be used when creating actions.</p> <p>Integration ID: <code>webhook:&lt;slug&gt;</code></p> <p>Configuration</p> <p>There is currently no additional configuration required for Web Hooks other than the configuration provided when creating them on the web.</p> <p>Example Usage</p> PythonCliShell <pre><code>action = Action(\n    \"success,error\",\n    integration=WebhookIntegration(id=\"webhook:demo-123\")\n)\ntask = Task.create(name=\"task name\", actions=[action])\n</code></pre> <p>Since no additional configuration is required we must pass an empty string:</p> <pre><code>taskbadger run \"demo task\" --action error,sucess webhook:demo-123 \"\" -- path/to/script.sh\n</code></pre> <pre><code>$ curl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"demo\", actions\":[{\"integration\":\"webhook:demo-test\",\"trigger\":\"success,error\",\"config\":{}}]}'\n</code></pre>"},{"location":"monitors/","title":"Scheduled Task Monitors","text":"<p>A common need in task monitoring is being notified if a scheduled task fails or doesn't run. It is easy to determine if tasks are successful using the task itself but detecting if a task fails or does not run at all requires a separate system.</p> <p>This is where Task Badger Monitors can help.</p> <p>By registering a task with Task Badger you can be sure that if the task fails or takes too long you will get notified.</p> <p>But what if the task never runs at all and never gets registered with Task Badger? We've got you covered there too. By telling Task Badger when you expect the task to run we can check and make sure that it does actually run when it's supposed to.</p>"},{"location":"monitors/#creating-a-monitor","title":"Creating a monitor","text":"<p>Monitors are created via the Task Badger web UI. When creating a monitor you will need to chose between two types: \"interval\" and \"cron\".</p>"},{"location":"monitors/#interval-monitors","title":"Interval Monitors","text":"<p>Use an interval monitor when your tasks are scheduled in a chain (one after the other) and not based on real time.</p> <p>For example, a task that runs every 5 minutes where each task is scheduled after the previous task starts / ends.</p>"},{"location":"monitors/#cron-monitors","title":"Cron Monitors","text":"<p>Use a cron monitor when you need more advanced scheduling or when your tasks are executed based on real time, for example, once per hour, on the hour.</p> <p>Cron monitor require writing cron schedule expressions. Cron expressions are split up in 5 fields as follows:</p> <pre><code># \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n# \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n# \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the month (1 - 31)\n# \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n# \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the week (0 - 6) (Sunday to Saturday;\n# \u2502 \u2502 \u2502 \u2502 \u2502                                   7 is also Sunday on some systems)\n# \u2502 \u2502 \u2502 \u2502 \u2502\n# \u2502 \u2502 \u2502 \u2502 \u2502\n# * * * * *\n</code></pre> <p>Here are some examples:</p> Expression Description <code>1 0 * * *</code> Daily at 1 minute past midnight <code>0 */2 * * *</code> Every 2nd hour <code>45 23 * * 6</code> 23:45 every Saturday (day 6) <p>For a more detailed explanation see Wikipedia.</p>"},{"location":"monitors/#set-up","title":"Set Up","text":"<p>Once you have created a monitor you need to configure your tasks to notify Task Badger when they run.</p>"},{"location":"monitors/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides an easy way to monitor your tasks. To associate a task with a monitor simply provide the monitor ID:</p> <pre><code>$ taskbadger run \"run script\" --monitor-id=XYZ -- path/to/script.sh\n</code></pre>"},{"location":"monitors/#using-the-api","title":"Using the API","text":"PythonShell <pre><code>from taskbadger import Task, StatusEnum\ntask = Task.create(name\"my-task\", status=StatsuEnum.processing, monitor_id=\"XYZ\")\ntry:\n    # Execute your task here...\nexcept Exception as e:\n    task.error({\n        \"exception\": str(e)\n    })\nelse:\n    task.update(status=StatusEnum.success)\n</code></pre> <p>Using the API directly you can pass the monitor ID vai the <code>X-TASKBADGER-MONITOR</code> header. The monitor ID only needs to be included in the request to create the task.</p> <pre><code>curl -X POST \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"X-TASKBADGER-MONITOR: %{MONITOR_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"demo task\", \"status\": \"processing\"}'\n# Response { \"id\": \"128aoa98e0fiq238\" ...}\n\n# Execute your scheduled task here...\n\ncurl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/128aoa98e0fiq238/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"success\"}'    \n</code></pre>"},{"location":"python-celery/","title":"Celery Integration","text":"<p>The Celery integration provides a task class that can be used to automatically create and update tasks in Task Badger from Celery tasks. Although you can use the basic SDK functions to create and update tasks from Celery tasks, the Celery integration simplifies the usage significantly.</p> <p>There are two ways you can use the Celery integration:</p> <ol> <li>Use the <code>CelerySystemIntegration</code> to automatically track all Celery tasks.</li> <li>Use the <code>taskbadger.celery.Task</code> class as the base class for Celery tasks you wish to track.</li> </ol> <p>You can use both mechanisms at the same time since the base class is useful if you want to access to the Task Badger task object within the body of the Celery task.</p>"},{"location":"python-celery/#celery-system-integration","title":"Celery System Integration","text":"<p>If you want to track all tasks, you can use the <code>CelerySystemIntegration</code> class. By default, this will track every task that is executed by the Celery workers (except the internal Celery tasks), including periodic / scheduled tasks.</p> <pre><code>import taskbadger\nfrom taskbadger.systems import CelerySystemIntegration\n\ntaskbadger.init(\n    organization_slug=\"my-org\",\n    project_slug=\"my-project\",\n    token=\"***\",\n    systems=[CelerySystemIntegration()],\n    tags={\"environment\": \"production\"}\n)\n</code></pre>"},{"location":"python-celery/#system-integration-options","title":"System Integration Options","text":"<p>The <code>CelerySystemIntegration</code> class takes a number of optional parameters:</p> <ul> <li><code>auto_track_tasks</code>: Set this to <code>False</code> to disable automatic tracking of tasks.</li> <li><code>includes</code>: A list of task names or patterns to include. If this is set, only tasks that match one of the patterns   will be tracked.</li> <li><code>excludes</code>: A list of task names or patterns to exclude. If this is set, tasks that match one of the patterns will   not be tracked.</li> <li> <p><code>record_task_args</code>: If <code>True</code>, the arguments passed to the task will be recorded in the Task Badger task data.</p> <p>Since v1.4.0</p> </li> </ul> <p>Exclusions take precedence over inclusions so if a task name matches both an include and an exclude, it will be excluded.</p>"},{"location":"python-celery/#celery-task-class","title":"Celery Task Class","text":"<p>To track individual tasks, or if you want access to the <code>Task</code> object within the body of the Celery task, you can use the <code>taskbadger.celery.Task</code> class as the base class for your Celery tasks. This can be used with or without the <code>CelerySystemIntegration</code>.</p> <p>This custom Celery task class tells Task Badger that the task should be tracked irrespective of any configuration passed to <code>CelerySystemIntegration</code> ie. even if the task matches an exclusion rule it will still be tracked if it is using <code>taskbadger.celery.Task</code> as its base.</p> <p>The task class also provides convenient access to the Task Badger task object within the body of the Celery task.</p>"},{"location":"python-celery/#basic-usage","title":"Basic Usage","text":"<p>To use the integration simply set the <code>base</code> parameter of your Celery task to <code>taskbadger.celery.Task</code>:</p> <p>This works the same with the <code>@celery.shared_task</code> decorator.</p> <pre><code>from celery import Celery\nfrom taskbadger.celery import Task\n\napp = Celery(\"tasks\")\n\n\n@app.task(base=Task)\ndef my_task():\n    pass\n\n\nresult = my_task.delay()\ntaskbadger_task_id = result.taskbadger_task_id\ntaskbadger_task = result.get_taskbadger_task()\n</code></pre> <p>Having made this change, a task will now be automatically created in Task Badger when the celery task is published. The Task Badger task will also be updated when the task completes.</p> <p>Info</p> <p>Note that Task Badger will only track the Celery task if it is run asynchronously. If the task is run synchronously via <code>.apply()</code>, by calling the function directly, or if <code>task_always_eager</code> has been set, the task will not be tracked.</p> <p>This also means that the <code>taskbadger_task_id</code> attribute of the result as well as the return value of <code>result.get_taskbadger_task()</code> will be <code>None</code> if the task is not being tracked by Task Badger.</p>"},{"location":"python-celery/#task-customization","title":"Task Customization","text":"<p>You can pass additional parameters to the Task Badger <code>Task</code> class which will be used when creating the task. This can be done by passing keyword arguments prefixed with <code>taskbadger_</code> to the <code>.appy_async()</code> function or to the task decorator.</p> <pre><code># using the task decorator\n\n@app.task(base=Task, taskbadger_monitor_id=\"xyz\")\ndef my_task(arg1, arg2):\n    ...\n\n\n# using individual keyword arguments\nmy_task.apply_async(\n    arg1, arg2,\n    taskbadger_name=\"my task\",\n    taskbadger_value_max=1000,\n    taskbadger_data={\"custom\": \"data\"},\n)\n\n# using a dictionary\nmy_task.apply_async(arg1, arg2, taskbadger_kwargs={\n    \"name\": \"my task\",\n    \"value_max\": 1000,\n    \"data\": {\"custom\": \"data\"}\n})\n</code></pre> <p>Order of Precedence</p> <p>Values passed via <code>apply_async</code> take precedence over values passed in the task decorator.</p> <p>In both the decorator and <code>apply_async</code>, if individual keyword arguments are used as well as the <code>taskbadger_kwargs</code> dictionary, the individual arguments will take precedence.</p> <p>Recording task args</p> <p>By default, the arguments passed to the task are not recorded in the Task Badger task data. To record the arguments, set the <code>taskbadger_record_task_args</code> parameter to <code>True</code> in the task decorator or in the <code>apply_async</code> call. This will override the value set in the <code>CelerySystemIntegration</code> if it is being used.</p> <p>Since v1.4.0</p>"},{"location":"python-celery/#accessing-the-task-object","title":"Accessing the Task Object","text":"<p>The <code>taskbadger.celery.Task</code> class provides access to the Task Badger task object via the <code>taskbadger_task</code> property of the Celery task. The Celery task instance can be accessed within a task function body by creating a bound task.</p> <pre><code>@app.task(bind=True, base=taskbadger.celery.Task)\ndef my_task(self, items):\n    # Retrieve the Task Badger task\n    task = self.taskbadger_task\n\n    for i, item in enumerate(items):\n        do_something(item)\n\n        if i % 100 == 0:\n            # Track progress\n            task.update(value=i)\n\n    # Mark the task as complete\n    # This is normally handled automatically when the task completes but we call it here so that we\n    # can also update the `value` property or other task properties.\n    task.success(value=len(items))\n</code></pre> <p>Note</p> <p>The <code>taskbadger_task</code> property will be <code>None</code> if the task is not being tracked by Task Badger. This could indicate that the Task Badger API has not been configured, there was an error creating the task, or the task is being run synchronously e.g. via <code>.apply()</code> or calling the task using <code>.map</code> or <code>.starmap</code>, <code>.chunk</code>.</p>"},{"location":"python-decorator/","title":"Python Function Decorator","text":"<p>In addition to the <code>taskbadger.Task</code> class and utility functions, there is also a function decorator that can be used to automatically create a task when a function is called.</p> <pre><code>from taskbadger import track\n\n@track(\"my task\")\ndef my_function():\n    pass\n</code></pre> <p>Using the decorator will create a task with the name provided and automatically update the task status to <code>success</code> when the function completes or <code>error</code> if an exception is raised.</p> <p>The decorator also applies the <code>taskbadger.Session</code> context manager to the function. See connection management.</p>"},{"location":"python-decorator/#api-docs","title":"API Docs","text":""},{"location":"python-decorator/#taskbadger.track","title":"taskbadger.track","text":"<pre><code>track(\n    func=None,\n    *,\n    name: str = None,\n    monitor_id: str = None,\n    max_runtime: int = None,\n    **task_kwargs,\n)\n</code></pre> <p>Decorator to track a function as a task.</p> <p>Usage: <pre><code>import taskbadger\n\n@taskbadger.track\ndef test(arg):\n    print(arg)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the task. Defaults to the fully qualified name of the function.</p> <code>None</code> <code>monitor_id</code> <code>str</code> <p>The ID of the monitor to associate the task with.</p> <code>None</code> <code>max_runtime</code> <code>int</code> <p>The maximum runtime of the task in seconds. If the task takes longer than this,          it will be marked as an error.</p> <code>None</code> <code>**kwargs</code> <p>See taskbadger.create_task</p> required"},{"location":"python/","title":"Task Badger Python SDK","text":"<p>On this page, we get you up and running with Task Badger's Python SDK.</p>"},{"location":"python/#install","title":"Install","text":"<p>Install the SDK using pip or your favorite pacakge manager: </p> <pre><code>pip install --upgrade taskbadger\n</code></pre>"},{"location":"python/#configure","title":"Configure","text":"<p>The SDK must be configured before you can use it to interact with the APIs.</p> <pre><code>import taskbadger\n\ntaskbadger.init(\n    organization_slug=\"my-org\",\n    project_slug=\"my-project\",\n    token=\"***\",\n    tags={\"environment\": \"production\"},\n)\n</code></pre> <p>Details about the slug configuration parameters can be found here.</p> Name Description organization_slug The organization identifier. project_slug The project identifier. token API authentication token. tags Global tags which are added to all tasks. systems System integrations such as Celery before_create A function that is called before a task is created. See Before Create Callback <p>If you attempt to use the SDK without configuring it you will get an error. To avoid this you can use the safe functions which will log any errors to the <code>taskbadger</code> logger.</p> <p>Tip</p> <p>Tags provided here will be applied to all tasks created using the SDK. If you need to add tags to individual tasks you can do so using the create and update methods or the <code>task.add_tag</code> method. Tags added manually will override the global tags.</p>"},{"location":"python/#usage","title":"Usage","text":"<p>The SDK provides a Task class which offers a convenient interface to the API.</p> <p>Tasks are created by calling the <code>Task.create</code> method:</p> <pre><code>from taskbadger import Task, Action, EmailIntegration\n\n# create a new task with custom data and an action definition\ntask = Task.create(\n    \"task name\",\n    data={\n        \"custom\": \"data\"\n    },\n    actions=[\n        Action(\n            trigger=\"*/10%,success,error\",\n            integration=EmailIntegration(to=\"me@example.com\")\n        )\n    ],\n    tags={\"tenant\": \"acme\"}\n)\n</code></pre> <p>Alternatively a task may be retrieved via the tasks ID:</p> <pre><code>from taskbadger import Task\n\ntask = Task.get(task_id)\n</code></pre> <p>The task object provides methods for updating the properties of a task, adding custom data and adding actions.</p>"},{"location":"python/#connection-management","title":"Connection management","text":"<p>The SDK will open a new connection for each request and close it when the request is complete. For instances where you wish to make multiple requests you can use the <code>taskbadger.Session</code> context manager:</p> <pre><code>from taskbadger import Session\n\nwith Session() as session:\n    task = Task.create(\"my task\")\n    task.update(status=\"success\")\n</code></pre> <p>If you are using the function decorator or the Celery integration,  session management is handled automatically within the body of the function or Celery task.</p>"},{"location":"python/#scope","title":"Scope","text":"<p>The SDK provides the <code>taskbadger.current_scope</code> context manager which can be used to set custom data and modify tags for the duration of the context. The content of the scope will be merged with any custom task data passed directly to any of the other API methods.</p> <pre><code>import socket\nimport taskbadger\n\nwith taskbadger.current_scope() as scope:\n    scope[\"hostname\"] = socket.gethostname()\n    scope.tag({\"tenant\": \"acme\"})\n</code></pre> <p>A common use case for this is to add request scoped context in frameworks like Django or Flask using a custom middleware. Here's an example for Django:</p> <pre><code>import taskbadger\n\ndef taskbadger_scope_middleware(get_response):\n    def middleware(request):\n        with taskbadger.current_scope() as scope:\n            scope[\"user\"] = request.user.username\n            scope.tag({\"tenant\": request.tenant.slug})\n            return get_response(request)\n\n    return middleware\n</code></pre> <p>Note</p> <p>The data passed directly to the API will take precedence over the data in the current scope. If the same key is present in the current scope as well as the data passed in directly, the value in the data passed directly will be used. The same applies to tags.</p>"},{"location":"python/#before-create-callback","title":"Before Create Callback","text":"<p>The <code>before_create</code> parameter in the <code>taskbadger.init</code> function allows you to define a function that will be called before a task is created. This function will be passed the task data as a dictionary and should return the modified task data.</p> <pre><code>def before_create(task_data: dict) -&gt; dict:\n    data = task_data.setdefault(\"data\", {})\n    data[\"custom\"] = \"data\"\n\n    tags = task_data.setdefault(\"tags\", {})\n    tags[\"tenant\"] = \"acme\"\n\n    return task_data\n</code></pre> <p>Since v1.5.0</p>"},{"location":"python/#python-reference","title":"Python Reference","text":""},{"location":"python/#taskbadger.Task","title":"taskbadger.Task","text":"<p>The Task class provides a convenient Python API to interact with Task Badger tasks.</p>"},{"location":"python/#taskbadger.Task.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(task_id: str) -&gt; Task\n</code></pre> <p>Get an existing task</p>"},{"location":"python/#taskbadger.Task.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    name: str,\n    status: StatusEnum = StatusEnum.PENDING,\n    value: int = None,\n    value_max: int = None,\n    data: dict = None,\n    max_runtime: int = None,\n    stale_timeout: int = None,\n    actions: list[Action] = None,\n    monitor_id: str = None,\n    tags: dict[str, str] = None,\n) -&gt; Task\n</code></pre> <p>Create a new task</p> <p>See taskbadger.create_task for more information.</p>"},{"location":"python/#taskbadger.Task.pre_processing","title":"pre_processing","text":"<pre><code>pre_processing()\n</code></pre> <p>Update the task status to <code>pre_processing</code>.</p>"},{"location":"python/#taskbadger.Task.starting","title":"starting","text":"<pre><code>starting()\n</code></pre> <p>Update the task status to <code>processing</code> and set the value to <code>0</code>.</p>"},{"location":"python/#taskbadger.Task.processing","title":"processing","text":"<pre><code>processing(value: int = None)\n</code></pre> <p>Update the task status to <code>processing</code> and set the value.</p>"},{"location":"python/#taskbadger.Task.post_processing","title":"post_processing","text":"<pre><code>post_processing(value: int = None)\n</code></pre> <p>Update the task status to <code>post_processing</code> and set the value.</p>"},{"location":"python/#taskbadger.Task.success","title":"success","text":"<pre><code>success(value: int = None)\n</code></pre> <p>Update the task status to <code>success</code> and set the value.</p>"},{"location":"python/#taskbadger.Task.error","title":"error","text":"<pre><code>error(value: int = None, data: dict = None)\n</code></pre> <p>Update the task status to <code>error</code> and set the value and data.</p>"},{"location":"python/#taskbadger.Task.canceled","title":"canceled","text":"<pre><code>canceled()\n</code></pre> <p>Update the task status to <code>cancelled</code></p>"},{"location":"python/#taskbadger.Task.update_status","title":"update_status","text":"<pre><code>update_status(status: StatusEnum)\n</code></pre> <p>Update the task status</p>"},{"location":"python/#taskbadger.Task.increment_value","title":"increment_value","text":"<pre><code>increment_value(amount: int)\n</code></pre> <p>Increment the task progress by adding the specified amount to the current value. If the task value is not set it will be set to <code>amount</code>.</p>"},{"location":"python/#taskbadger.Task.update_value","title":"update_value","text":"<pre><code>update_value(\n    value: int, value_step: int = None, rate_limit: int = None\n) -&gt; bool\n</code></pre> <p>Update task progress.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The new value to set.</p> required <code>value_step</code> <code>int</code> <p>The minimum change in value required to trigger an update.</p> <code>None</code> <code>rate_limit</code> <code>int</code> <p>The minimum interval between updates in seconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the task was updated, False otherwise</p> <p>If either <code>value_step</code> or <code>rate_limit</code> is set, the task will only be updated if the specified conditions are met. If both are set, the task will be updated if either condition is met.</p>"},{"location":"python/#taskbadger.Task.set_value_max","title":"set_value_max","text":"<pre><code>set_value_max(value_max: int)\n</code></pre> <p>Set the <code>value_max</code>.</p>"},{"location":"python/#taskbadger.Task.update","title":"update","text":"<pre><code>update(\n    name: str = None,\n    status: StatusEnum = None,\n    value: int = None,\n    value_max: int = None,\n    data: dict = None,\n    max_runtime: int = None,\n    stale_timeout: int = None,\n    actions: list[Action] = None,\n    tags: dict[str, str] = None,\n    data_merge_strategy: Any = None,\n)\n</code></pre> <p>Generic update method used to update any of the task fields.</p> <p>This can also be used to add actions.</p> <p>See taskbadger.update_task for more information.</p>"},{"location":"python/#taskbadger.Task.add_actions","title":"add_actions","text":"<pre><code>add_actions(actions: list[Action])\n</code></pre> <p>Add actions to the task.</p>"},{"location":"python/#taskbadger.Task.tag","title":"tag","text":"<pre><code>tag(tags: dict[str, str])\n</code></pre> <p>Add tags to the task.</p>"},{"location":"python/#taskbadger.Task.ping","title":"ping","text":"<pre><code>ping(rate_limit=None) -&gt; bool\n</code></pre> <p>Update the task without changing any values. This can be used in conjunction with 'stale_timeout' to indicate that the task is still running.</p> <p>Parameters:</p> Name Type Description Default <code>rate_limit</code> <p>The minimum interval between pings in seconds. If set this will only update the task if the last update was more than <code>rate_limit</code> seconds ago.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the task was updated, False otherwise</p>"},{"location":"python/#low-level-functions","title":"Low level functions","text":"<p>In addition to the <code>taskbadger.Task</code> class. There are also a number of functions that provide lower level access to the API:</p>"},{"location":"python/#taskbadger.get_task","title":"taskbadger.get_task","text":"<pre><code>get_task(task_id: str) -&gt; Task\n</code></pre> <p>Fetch a Task from the API based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to fetch.</p> required"},{"location":"python/#taskbadger.create_task","title":"taskbadger.create_task","text":"<pre><code>create_task(\n    name: str,\n    status: StatusEnum = StatusEnum.PENDING,\n    value: int = None,\n    value_max: int = None,\n    data: dict = None,\n    max_runtime: int = None,\n    stale_timeout: int = None,\n    actions: list[Action] = None,\n    monitor_id: str = None,\n    tags: dict[str, str] = None,\n) -&gt; Task\n</code></pre> <p>Create a Task.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the task.</p> required <code>status</code> <code>StatusEnum</code> <p>The task status.</p> <code>PENDING</code> <code>value</code> <code>int</code> <p>The current 'value' of the task.</p> <code>None</code> <code>value_max</code> <code>int</code> <p>The maximum value the task is expected to achieve.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Custom task data.</p> <code>None</code> <code>max_runtime</code> <code>int</code> <p>Maximum expected runtime (seconds).</p> <code>None</code> <code>stale_timeout</code> <code>int</code> <p>Maximum allowed time between updates (seconds).</p> <code>None</code> <code>actions</code> <code>list[Action]</code> <p>Task actions.</p> <code>None</code> <code>monitor_id</code> <code>str</code> <p>ID of the monitor to associate this task with.</p> <code>None</code> <code>tags</code> <code>dict[str, str]</code> <p>Dictionary of namespace -&gt; value tags.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Task</code> <code>Task</code> <p>The created Task object.</p>"},{"location":"python/#taskbadger.update_task","title":"taskbadger.update_task","text":"<pre><code>update_task(\n    task_id: str,\n    name: str = None,\n    status: StatusEnum = None,\n    value: int = None,\n    value_max: int = None,\n    data: dict = None,\n    max_runtime: int = None,\n    stale_timeout: int = None,\n    actions: list[Action] = None,\n    tags: dict[str, str] = None,\n) -&gt; Task\n</code></pre> <p>Update a task. Requires only the task ID and fields to update.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>name</code> <code>str</code> <p>The name of the task.</p> <code>None</code> <code>status</code> <code>StatusEnum</code> <p>The task status.</p> <code>None</code> <code>value</code> <code>int</code> <p>The current 'value' of the task.</p> <code>None</code> <code>value_max</code> <code>int</code> <p>The maximum value the task is expected to achieve.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Custom task data.</p> <code>None</code> <code>max_runtime</code> <code>int</code> <p>Maximum expected runtime (seconds).</p> <code>None</code> <code>stale_timeout</code> <code>int</code> <p>Maximum allowed time between updates (seconds).</p> <code>None</code> <code>actions</code> <code>list[Action]</code> <p>Task actions.</p> <code>None</code> <code>tags</code> <code>dict[str, str]</code> <p>Dictionary of namespace -&gt; value tags.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Task</code> <code>Task</code> <p>The updated Task object.</p>"},{"location":"python/#safe-functions","title":"Safe functions","text":"<p>For instances where you prefer not to handle errors you can use the following function which will handle all errors and log them to the <code>taskbadger</code> logger.</p> <p>These can also be used safely in instances where the API has not been configured via <code>taskbadger.init</code>.</p>"},{"location":"python/#taskbadger.create_task_safe","title":"taskbadger.create_task_safe","text":"<pre><code>create_task_safe(name: str, **kwargs: P.kwargs) -&gt; Optional[Task]\n</code></pre> <p>Safely create a task. Any errors are handled and logged.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the task.</p> required <code>**kwargs</code> <code>kwargs</code> <p>See taskbadger.create_task</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Task]</code> <p>The created task or None</p>"},{"location":"python/#taskbadger.update_task_safe","title":"taskbadger.update_task_safe","text":"<pre><code>update_task_safe(task_id: str, **kwargs: P.kwargs) -&gt; Optional[Task]\n</code></pre> <p>Safely update a task. Any errors are handled and logged.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>**kwargs</code> <code>kwargs</code> <p>See taskbadger.update_task</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Task]</code> <p>The updated task or None</p>"},{"location":"quick/","title":"Get the Badger working!","text":"<p>Let's discover Task Badger in less than 5 minutes.</p>"},{"location":"quick/#setup","title":"Setup","text":"<p>In order to use the API you will need the following details:</p> <ul> <li>Organization slug<ul> <li>You can get this by going to 'My Organization'  </li> </ul> </li> <li>Project slug<ul> <li>Go to the 'Projects' page. The slug for each project is listed. </li> </ul> </li> <li>API Key<ul> <li>Create one on your Profile page</li> </ul> </li> </ul>"},{"location":"quick/#montior-celery-tasks","title":"Montior Celery Tasks","text":"<p>When using the Celery integration you can use the <code>CelerySystemIntegration</code> class to automatically record tasks.</p> <pre><code>from celery import Celery\nimport taskbadger\nfrom taskbadger.systems.celery import CelerySystemIntegration\n\napp = Celery('hello', broker='amqp://guest@localhost//')\n\ntaskbadger.init(\n    organization_slug=\"my-org\",\n    project_slug=\"my-project\",\n    token=\"***\",\n    tags={\"environment\": \"production\"},\n    systems=[CelerySystemIntegration(record_task_args=True)]\n)\n\n@app.task\ndef hello(who):\n    return f'hello {who}'\n</code></pre> <p>This is all the configuration that is needed to do basic task tracking with Celery.</p>"},{"location":"quick/#monitor-a-task-from-the-command-line","title":"Monitor a task from the command line","text":"<p>The Task Badger CLI allows you to run commands from the shell and have them monitored by Task Badger. The task status will get updated once the command completes.</p>"},{"location":"quick/#install-and-configure-the-cli","title":"Install and configure the CLI","text":"<pre><code>$ python3 -m pip install taskbadger\n\n$ taskbadger configure\n\nOrganization slug: my-org \nProject slug: project-x \nAPI Key: XYZ.ABC\n\nConfig written to ~/.config/taskbadger/confi\n</code></pre>"},{"location":"quick/#use-the-cli-to-run-and-monitor-the-command","title":"Use the CLI to run and monitor the command","text":"<pre><code>$ taskbadger run \"demo task\" \\\n  --action \"error email to:me@test.com\" \\\n  --tag \"environment=staging\" \\\n  -- path/to/script.sh\n\nTask created: https://taskbadger.net/public/tasks/xyz/\n</code></pre> <p>If the command completes with a non-zero exit code the task status will be set to <code>error</code> and an email will be sent to <code>me@test.com</code>.</p> <p>See more about the CLI.</p>"},{"location":"quick/#use-the-api-directly","title":"Use the API directly","text":"PythonShell <p>Install the <code>taskbadger</code> Python library:</p> <pre><code>$ python3 -m pip install taskbadger\n</code></pre> <p>Configure the API client:</p> <pre><code>import taskbadger\n\ntaskbadger.init(\n    organization_slug=\"my-org\",\n    project_slug=\"my-project\",\n    token=\"***\",\n    tags={\"environment\": \"production\"},\n)\n</code></pre> <p>Export the configuration parameters:</p> <pre><code>export ORG=\"my-org\"\nexport PROJECT=\"my-project\"\nexport API_KEY=\"***\"\n</code></pre>"},{"location":"quick/#creating-a-task","title":"Creating a task","text":"<p>Creating a task is very simple. Make a POST request to the API with the task data.</p> PythonShell <pre><code>&gt; task = Task.create(\"task name\", stale_timeout=10, tags={\"environment\": \"staging\"})\n&gt; task.id\n\"128aoa98e0fiq238\"\n</code></pre> <pre><code>$ curl -X POST \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"demo task\", \"stale_timeout\": 10, \"tags\": {\"environment\": \"staging\"}}'\n</code></pre> <p>The response will include the task ID which is needed for updating the task.</p> Response<pre><code>{\n  \"id\": \"{task_id}\",\n  \"organization\": \"my-org\",\n  \"project\": \"my-project\",\n  \"name\": \"demo task\",\n  \"status\": \"pending\",\n  \"value\": null,\n  \"value_max\": null,\n  \"value_percent\": null,\n  \"data\": null,\n  \"max_runtime\": null,\n  \"stale_timeout\": 10,\n  \"start_time\": null,\n  \"end_time\": null,\n  \"created\": \"2022-09-22T06:53:40.683555Z\",\n  \"updated\": \"2022-09-22T06:53:40.683555Z\"\n  \"url\": \"https://taskbadger.net/a/{example_org/tasks/{task_id}/\",\n  \"public_url\": \"https://taskbadger.net/public/tasks/{task_id}/\",\n  \"tags\": {\"environment\": \"staging\"}\n}\n</code></pre> <p>The task will now be listed in the task list: <code>https://taskbadger.net/a/${ORG}/tasks/</code>.</p>"},{"location":"quick/#update-task-progress","title":"Update task progress","text":"<p>Here we update the task <code>status</code> and <code>value</code>. By default, a task's value can range from 0 to 100.</p> PythonShell <pre><code>from taskbadger import StatusEnum\ntask.update(status=StatusEnum.PROCESSING, value=5)\n</code></pre> <pre><code>$ curl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/${TASK_ID}/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"processing\", \"value\": 5}'\n</code></pre>"},{"location":"quick/#add-an-action-to-the-task","title":"Add an action to the task","text":"<p>Here we update create a new action for the task so that we get notified when the task completes.</p> PythonShell <pre><code>from taskbadger import Action, EmailIntegration\ntask.add_actions([\n    Action(\n        \"*/10%,success,error\",\n        integration=EmailIntegration(to=\"me@example.com\")\n    )\n])\n</code></pre> <pre><code>$ curl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/${TASK_ID}/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"actions\":[{\"integration\":\"email\",\"trigger\":\"success,error\",\"config\":{\"to\":\"me@example.com\"}}]}'\n</code></pre> <p>Read more about actions.</p>"},{"location":"quick/#mark-the-task-complete","title":"Mark the task complete","text":"<p>When the task is complete update the status to either <code>success</code> or <code>error</code>. The value may also be updated to 100.</p> PythonShell <pre><code>task.update(status=StatusEnum.SUCCESS, value=100)\n</code></pre> <pre><code>$ curl -X PATCH \"https://taskbadger.net/api/${ORG}/${PROJECT}/tasks/${TASK_ID}/\" \\\n  -H \"Authorization: Bearer ${API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"success\", \"value\": 100}'\n</code></pre> <p>Also check your email to see if you got the notification.</p>"},{"location":"quick/#a-real-example","title":"A real example","text":"<p>Take a look at how to apply this to a real example.</p>"},{"location":"web_example/","title":"Example Walkthrough","text":"<p>Here we'll see how to use Task Badger in a web setting to create a task during a request and then updated it as the task is processed on the backend.</p> <p>In the following example we'll be using Django and Celery.</p> <p>Tip</p> <p>If using the Task Badger task for local progress tracking seems a bit heavy for your use case, you could use celery-progress for local tracking and maintain the Task Badger task purerly for remote tracking, metrics, alerts, integrations etc.</p>"},{"location":"web_example/#option-1-use-the-core-api","title":"Option 1: Use the Core API","text":""},{"location":"web_example/#1-create-the-task-in-a-view","title":"1. Create the task in a view","text":"views.py<pre><code>from django.conf import settings\nfrom taskbadger import StatusEnum, Task\nfrom apps.export.tasks import export_user_data\n\nNOTIFY_EMAIL = settings.ADMINS[0][1]\n\n\n@require_POST\ndef export_data(request):\n    task = Task.create(\n        \"data export\",\n        data={\"user_id\": request.user.id},\n        actions=[Action(\"error,stale\", integration=EmailIntegration(to=NOTIFY_EMAIL))],\n        stale_timeout=60,  # seconds\n    )\n\n    export_user_data.delay(task_id=task.id, user_id=request.user.id)\n    return JsonResponse({\"task_id\": task.id})\n</code></pre> <p>In addition to creating the task, we've also added an action so that we will get notified if the task fails or does not complete.</p>"},{"location":"web_example/#2-update-the-task","title":"2. Update the task","text":"tasks.py<pre><code>from celery.app import shared_task\nfrom taskbadger import StatusEnum, Task\n\n@shared_task\ndef export_user_data(task_id, user_id):\n    task = Task.get(task_id)\n    task.update(status=StatusEnum.PROCESSING)\n\n    try:\n        compile_export(task, user_id)  # this also updates the task progress\n    except Exception as e:\n        task.error(data={\n            \"error\": str(e)\n        })\n        raise\n\n    task.success(100)\n</code></pre>"},{"location":"web_example/#3-expose-the-task-status-for-the-ui","title":"3. Expose the task status for the UI","text":"views.py<pre><code>@require_GET\ndef poll_task_status(request, task_id):\n    task = Task.get(task_id)\n\n    return JsonResponse({\n        \"status\": task.status,\n        \"value\": task.value,\n        \"value_percent\": task.value_percent\n    })\n</code></pre>"},{"location":"web_example/#option-2-use-the-celery-integration","title":"Option 2: Use the Celery integration","text":"<p>Use the Task Badger Celery Task class as the base class for your Celery task:</p> tasks.py<pre><code>from celery.app import shared_task\nfrom taskbadger.celery import Task\n\n@shared_task(bind=True, base=Task, taskbadger_kwargs={\n    \"actions\": [Action(\"error,stale\", integration=EmailIntegration(to=settings.ADMINS[0][1]))],\n    \"stale_timeout\": 5\n})\ndef export_user_data(self, user_id):\n    task = self.taskbadger_task\n\n    try:\n        compile_export(task, user_id)  # this also updates the task progress\n    except Exception as e:\n        task.error(data={\n            \"error\": str(e)\n        })\n        raise\n\n    task.success(100)\n</code></pre> <p>In the view we can get the Task Badger task ID from the Celery task result:</p> views.py<pre><code>from apps.export.tasks import export_user_data\n\n\n@require_POST\ndef export_data(request):\n    task = export_user_data.delay(user_id=request.user.id, taskbadger_data={\"user_id\": request.user.id})\n    tb_task_id = task.info.get(\"taskbadger_task_id\")\n    return JsonResponse({\"task_id\": tb_task_id})\n\n\n@require_GET\ndef poll_task_status(request, task_id):\n    # same as above\n</code></pre>"}]}